/*    
    Copyright (C) Paul Falstad and Iain Sharp

    This file is part of CircuitJS1.

    CircuitJS1 is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    CircuitJS1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with CircuitJS1.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.lushprojects.circuitjs1.client;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

/**
 * ComputedValues - Manages computed values storage and tracking for circuit elements
 * 
 * This class provides a centralized way to store and retrieve computed values that
 * are generated by elements like TableElm and consumed by elements like TableVoltageElm.
 * It replaces the computed values functionality that was previously embedded in LabeledNodeElm.
 * 
 * Key features:
 * - Store computed values by name (String key -> Double value)
 * - Track which values have been computed in the current simulation step
 * - Track which table element is the "master" computer for each value
 * - Clear all values or reset tracking flags as needed
 * - Thread-safe access to computed values
 */
public class ComputedValues {
    
    // Storage for computed values: name -> value
    private static HashMap<String, Double> computedValues;
    
    // Track which values have been computed this simulation step
    private static Set<String> computedThisStep;
    
    // Track which table element computes each value (name -> TableElm reference)
    private static HashMap<String, Object> computedByTable;
    
    // Track the priority of the master table for each value (name -> priority)
    private static HashMap<String, Integer> masterTablePriorities;
    
    // Initialize storage if needed
    private static void ensureInitialized() {
        if (computedValues == null) {
            computedValues = new HashMap<String, Double>();
        }
        if (computedThisStep == null) {
            computedThisStep = new HashSet<String>();
        }
        if (computedByTable == null) {
            computedByTable = new HashMap<String, Object>();
        }
        if (masterTablePriorities == null) {
            masterTablePriorities = new HashMap<String, Integer>();
        }
    }
    
    /**
     * Set a computed value for a given name with the computing table element
     * Used by elements like TableElm to store calculated values
     * 
     * @param name The name/key for the computed value
     * @param value The computed value to store
     * @param computingTable The table element that computed this value (can be null)
     */
    public static void setComputedValue(String name, double value, Object computingTable) {
        if (name == null || name.isEmpty()) return;
        
        ensureInitialized();
        computedValues.put(name, value);
        if (computingTable != null) {
            computedByTable.put(name, computingTable);
        }
    }
    
    /**
     * Set a computed value for a given name (backward compatibility)
     * Used by elements like TableElm to store calculated values
     * 
     * @param name The name/key for the computed value
     * @param value The computed value to store
     */
    public static void setComputedValue(String name, double value) {
        setComputedValue(name, value, null);
    }
    
    /**
     * Get a computed value by name
     * Used by elements like TableVoltageElm and Expr to retrieve values
     * 
     * @param name The name/key of the computed value
     * @return The computed value, or null if not found
     */
    public static Double getComputedValue(String name) {
        if (name == null || computedValues == null) return null;
        return computedValues.get(name);
    }
    
    /**
     * Check if a computed value exists for the given name
     * 
     * @param name The name/key to check
     * @return true if a computed value exists, false otherwise
     */
    public static boolean hasComputedValue(String name) {
        if (name == null || computedValues == null) return false;
        return computedValues.containsKey(name) && computedValues.get(name) != null;
    }
    
    /**
     * Get the table element that computed a specific value
     * 
     * @param name The name/key of the computed value
     * @return The table element that computed this value, or null if not found/set
     */
    public static Object getComputingTable(String name) {
        if (name == null || computedByTable == null) return null;
        return computedByTable.get(name);
    }
    
    /**
     * Check if a specific table element is the master computer for a given value name
     * 
     * @param name The name/key of the computed value
     * @param table The table element to check
     * @return true if this table is the master computer for this value
     */
    public static boolean isMasterTable(String name, Object table) {
        if (name == null || table == null) return false;
        Object masterTable = getComputingTable(name);
        return table.equals(masterTable);
    }
    
    /**
     * Clear all computed values
     * Called by CirSim when resetting the circuit state
     */
    public static void clearComputedValues() {
        if (computedValues != null) {
            computedValues.clear();
        }
        if (computedByTable != null) {
            computedByTable.clear();
        }
    }
    
    /**
     * Reset the "computed this step" tracking flags
     * Called by CirSim at the start of each simulation step
     */
    public static void resetComputedFlags() {
        ensureInitialized();
        computedThisStep.clear();
    }
    
    /**
     * Check if a value has been computed in the current simulation step
     * Used to avoid duplicate computations and circular dependencies
     * 
     * @param name The name/key to check
     * @return true if the value was computed this step, false otherwise
     */
    public static boolean isComputedThisStep(String name) {
        if (computedThisStep == null) return false;
        return computedThisStep.contains(name);
    }
    
    /**
     * Mark a value as having been computed in the current simulation step
     * Used by elements to track their computation to avoid cycles
     * 
     * @param name The name/key of the value that was computed
     */
    public static void markComputedThisStep(String name) {
        if (name == null) return;
        ensureInitialized();
        computedThisStep.add(name);
    }
    
    /**
     * Get all computed value names (for debugging/inspection)
     * 
     * @return Array of all computed value names, or empty array if none
     */
    public static String[] getComputedValueNames() {
        if (computedValues == null || computedValues.isEmpty()) {
            return new String[0];
        }
        Set<String> keySet = computedValues.keySet();
        return keySet.toArray(new String[keySet.size()]);
    }
    
    /**
     * Get the number of computed values currently stored
     * 
     * @return Number of computed values
     */
    public static int getComputedValueCount() {
        return (computedValues != null) ? computedValues.size() : 0;
    }
    
    /**
     * Register a table element as wanting to compute a specific value
     * This is used during circuit initialization to determine which table
     * should be the "master" computer for each output name when multiple
     * tables have the same output name.
     * 
     * The table with the highest priority becomes the master.
     * If priorities are equal, the first table to register becomes the master.
     * 
     * @param name The output name this table wants to compute
     * @param table The table element
     * @param priority The priority of this table (higher = higher priority)
     * @return true if this table became the master, false if another table is already master with higher/equal priority
     */
    public static boolean registerMasterTable(String name, Object table, int priority) {
        if (name == null || name.isEmpty() || table == null) return false;
        
        ensureInitialized();
        
        // If no table is registered for this name yet, this table becomes the master
        if (!computedByTable.containsKey(name)) {
            computedByTable.put(name, table);
            masterTablePriorities.put(name, priority);
            return true;
        }
        
        // Check if this table has higher priority than the current master
        Integer currentPriority = masterTablePriorities.get(name);
        if (currentPriority == null || priority > currentPriority) {
            // This table has higher priority - replace the current master
            computedByTable.put(name, table);
            masterTablePriorities.put(name, priority);
            return true;
        }
        
        // Another table is already the master with equal or higher priority
        return false;
    }
    
    /**
     * Register a table element as wanting to compute a specific value (backward compatibility)
     * Uses default priority of 5
     * 
     * @param name The output name this table wants to compute
     * @param table The table element
     * @return true if this table became the master, false if another table is already master
     */
    public static boolean registerMasterTable(String name, Object table) {
        return registerMasterTable(name, table, 5); // Default priority
    }
    
    /**
     * Clear the master table registrations
     * Called when the circuit is reset or rebuilt
     */
    public static void clearMasterTables() {
        if (computedByTable != null) {
            computedByTable.clear();
        }
        if (masterTablePriorities != null) {
            masterTablePriorities.clear();
        }
    }
    
    /**
     * Debug method to get information about master table assignments
     * 
     * @return Array of strings describing master table assignments
     */
    public static String[] getMasterTableInfo() {
        if (computedByTable == null || computedByTable.isEmpty()) {
            return new String[] { "No master tables registered" };
        }
        
        String[] info = new String[computedByTable.size()];
        int i = 0;
        for (String name : computedByTable.keySet()) {
            Object table = computedByTable.get(name);
            String tableInfo = (table != null) ? table.getClass().getSimpleName() + "@" + table.hashCode() : "null";
            info[i++] = name + " -> " + tableInfo;
        }
        return info;
    }
    
    /**
     * Get all master stock names (all keys in computedByTable)
     * Used by CurrentTransactionsMatrixElm to auto-populate columns
     * 
     * @return Array of master stock names, or empty array if none
     */
    public static String[] getAllMasterStockNames() {
        if (computedByTable == null || computedByTable.isEmpty()) {
            return new String[0];
        }
        Set<String> keySet = computedByTable.keySet();
        return keySet.toArray(new String[keySet.size()]);
    }
    
    /**
     * Get all master stock names excluding tables with specified title
     * Used by CurrentTransactionsMatrixElm to exclude itself from the list
     * 
     * @param excludeTitle Title of tables to exclude (e.g., "Current Transactions Matrix")
     * @return Array of master stock names from non-excluded tables
     */
    public static String[] getMasterStockNamesExcluding(String excludeTitle) {
        if (computedByTable == null || computedByTable.isEmpty()) {
            return new String[0];
        }
        
        // Filter out stocks from tables with the excluded title
        java.util.ArrayList<String> filtered = new java.util.ArrayList<String>();
        for (String name : computedByTable.keySet()) {
            Object table = computedByTable.get(name);
            if (table instanceof TableElm) {
                TableElm tableElm = (TableElm) table;
                if (excludeTitle == null || !excludeTitle.equals(tableElm.tableTitle)) {
                    filtered.add(name);
                }
            } else {
                // Not a TableElm, include it
                filtered.add(name);
            }
        }
        
        return filtered.toArray(new String[filtered.size()]);
    }
}