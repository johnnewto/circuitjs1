/*    
    Copyright (C) Paul Falstad and Iain Sharp

    This file is part of CircuitJS1.

    CircuitJS1 is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    CircuitJS1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with CircuitJS1.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.lushprojects.circuitjs1.client;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

/**
 * ComputedValues - Manages computed values storage and tracking for circuit elements
 * 
 * This class provides a centralized way to store and retrieve computed values that
 * are generated by elements like TableElm and consumed by elements like TableVoltageElm.
 * It replaces the computed values functionality that was previously embedded in LabeledNodeElm.
 * 
 * Key features:
 * - Store computed values by name (String key -> Double value)
 * - Track which values have been computed in the current simulation step
 * - Track which table element is the "master" computer for each value
 * - Maintain separate "converged" values for display elements to use
 * - Clear all values or reset tracking flags as needed
 * - Thread-safe access to computed values
 * 
 * Three-value system (double-buffering for order-independent evaluation):
 * - "current" values: Stable values from end of last doStep() cycle - READ from during doStep()
 * - "pending" values: New values being written during current doStep() - WRITE to during doStep()
 * - "converged" values: Committed at end of timestep, used by display elements
 * 
 * Double-buffering workflow:
 * 1. At start of doStep() cycle: current values are stable from previous cycle
 * 2. Elements READ from current (getComputedValue), WRITE to pending (setComputedValue)
 * 3. After ALL elements complete doStep(): call commitPendingToCurrentValues()
 * 4. Pending values become current, making them available for next iteration
 * 5. At end of converged timestep: call commitConvergedValues() for display elements
 * 
 * This makes evaluation order-independent: Element A and B both see the same
 * "current" values regardless of which doStep() runs first.
 */
public class ComputedValues {
    
    // Storage for current values: name -> value (stable, read from during doStep)
    private static HashMap<String, Double> computedValues;
    
    // Storage for pending values: name -> value (written to during doStep, committed after)
    private static HashMap<String, Double> pendingValues;
    
    // Storage for converged values: name -> value (committed at end of timestep)
    // Display elements (scopes, SFC tables) should read from this for stable display
    private static HashMap<String, Double> convergedValues;
    
    // Flag to enable/disable double-buffering (allows gradual migration)
    private static boolean doubleBufferingEnabled = true;
    
    // Track which values have been computed this simulation step
    private static Set<String> computedThisStep;
    
    // Track which table element computes each value (name -> TableElm reference)
    private static HashMap<String, Object> computedByTable;
    
    // Track the priority of the master table for each value (name -> priority)
    private static HashMap<String, Integer> masterTablePriorities;
    
    // Initialize storage if needed
    private static void ensureInitialized() {
        if (computedValues == null) {
            computedValues = new HashMap<String, Double>();
        }
        if (pendingValues == null) {
            pendingValues = new HashMap<String, Double>();
        }
        if (convergedValues == null) {
            convergedValues = new HashMap<String, Double>();
        }
        if (computedThisStep == null) {
            computedThisStep = new HashSet<String>();
        }
        if (computedByTable == null) {
            computedByTable = new HashMap<String, Object>();
        }
        if (masterTablePriorities == null) {
            masterTablePriorities = new HashMap<String, Integer>();
        }
    }
    
    /**
     * Enable or disable double-buffering mode.
     * When enabled: writes go to pending buffer, reads come from current buffer
     * When disabled: writes and reads both use current buffer (legacy behavior)
     * 
     * @param enabled true to enable double-buffering, false for immediate mode
     */
    public static void setDoubleBufferingEnabled(boolean enabled) {
        doubleBufferingEnabled = enabled;
    }
    
    /**
     * Check if double-buffering is enabled.
     * @return true if double-buffering is enabled
     */
    public static boolean isDoubleBufferingEnabled() {
        return doubleBufferingEnabled;
    }
    
    /**
     * Set a computed value for a given name with the computing table element
     * Used by elements like TableElm to store calculated values
     * 
     * When double-buffering is enabled, this writes to the pending buffer.
     * The value becomes visible to other elements after commitPendingToCurrentValues().
     * 
     * @param name The name/key for the computed value
     * @param value The computed value to store
     * @param computingTable The table element that computed this value (can be null)
     */
    public static void setComputedValue(String name, double value, Object computingTable) {
        if (name == null || name.isEmpty()) return;
        
        ensureInitialized();
        
        if (doubleBufferingEnabled) {
            // Write to pending buffer (will be committed after all doStep() calls)
            pendingValues.put(name, value);
        } else {
            // Legacy immediate mode: write directly to current values
            computedValues.put(name, value);
        }
        
        if (computingTable != null) {
            computedByTable.put(name, computingTable);
        }
    }
    
    /**
     * Set a computed value for a given name (backward compatibility)
     * Used by elements like TableElm to store calculated values
     * 
     * @param name The name/key for the computed value
     * @param value The computed value to store
     */
    public static void setComputedValue(String name, double value) {
        setComputedValue(name, value, null);
    }
    
    /**
     * Get a computed value by name (current/subiteration value)
     * Used by simulation elements during doStep() for calculations.
     * 
     * When double-buffering is enabled, this reads from the current buffer
     * (values committed from the previous doStep cycle), making evaluation
     * order-independent.
     * 
     * NOTE: Display elements should use getConvergedValue() instead for stable display.
     * 
     * @param name The name/key of the computed value
     * @return The computed value, or null if not found
     */
    public static Double getComputedValue(String name) {
        if (name == null || computedValues == null) return null;
        return computedValues.get(name);
    }
    
    /**
     * Get a pending value by name (value written this doStep cycle, not yet committed)
     * Used internally or for debugging. Most code should use getComputedValue().
     * 
     * @param name The name/key of the pending value
     * @return The pending value, or null if not found
     */
    public static Double getPendingValue(String name) {
        if (name == null || pendingValues == null) return null;
        return pendingValues.get(name);
    }
    
    /**
     * Commit pending values to current values.
     * Called by CirSim AFTER all elements complete their doStep() calls.
     * This makes the new values visible to all elements in the next iteration.
     * 
     * For order-independent evaluation, call sequence is:
     * 1. All elements doStep() - read from current, write to pending
     * 2. commitPendingToCurrentValues() - pending becomes current
     * 3. Repeat until converged
     */
    public static void commitPendingToCurrentValues() {
        if (!doubleBufferingEnabled) return;
        
        ensureInitialized();
        
        // Move all pending values to current
        for (String name : pendingValues.keySet()) {
            Double value = pendingValues.get(name);
            if (value != null) {
                computedValues.put(name, value);
            }
        }
        // Don't clear pending - keep for reference during timestep
        // It will be overwritten by new values in the next doStep cycle
    }
    
    /**
     * Clear pending values buffer.
     * Called at the start of a new timestep to ensure clean state.
     */
    public static void clearPendingValues() {
        if (pendingValues != null) {
            pendingValues.clear();
        }
    }
    
    /**
     * Get a converged value by name (stable value for display)
     * Used by display elements (scopes, SFC tables, etc.) to get stable values.
     * Returns the value from the end of the PREVIOUS timestep, which is guaranteed
     * to be converged and stable across all subiterations of the current timestep.
     * 
     * @param name The name/key of the computed value
     * @return The converged value, or the current value if no converged value exists
     */
    public static Double getConvergedValue(String name) {
        if (name == null) return null;
        ensureInitialized();
        
        // First try converged values (stable)
        Double converged = convergedValues.get(name);
        if (converged != null) {
            return converged;
        }
        
        // Fall back to current value (for first timestep before any commit)
        return computedValues.get(name);
    }
    
    /**
     * Get a lagged value by name (STRICTLY from previous timestep only)
     * Used by lag() function for sfcr-style V[-1] notation.
     * Returns ONLY the converged value from the previous timestep.
     * Does NOT fall back to current values - returns null if no converged value exists.
     * 
     * This ensures lag(X) returns a stable value that doesn't change during subiterations.
     * On the first timestep (before any convergence), this returns null.
     * 
     * @param name The name/key of the computed value
     * @return The converged value from previous timestep, or null if none exists
     */
    public static Double getLaggedValue(String name) {
        if (name == null) return null;
        ensureInitialized();
        
        // ONLY return converged values - never fall back to current
        return convergedValues.get(name);
    }
    
    /**
     * Commit all current computed values as converged values.
     * Called by CirSim at the end of each successfully converged timestep.
     * After this call, getConvergedValue() will return the newly committed values.
     */
    public static void commitConvergedValues() {
        ensureInitialized();
        
        // Copy all current values to converged values
        for (String name : computedValues.keySet()) {
            Double value = computedValues.get(name);
            if (value != null) {
                convergedValues.put(name, value);
            }
        }
    }
    
    /**
     * Check if a computed value exists for the given name
     * 
     * @param name The name/key to check
     * @return true if a computed value exists, false otherwise
     */
    public static boolean hasComputedValue(String name) {
        if (name == null || computedValues == null) return false;
        return computedValues.containsKey(name) && computedValues.get(name) != null;
    }
    
    /**
     * Get the table element that computed a specific value
     * 
     * @param name The name/key of the computed value
     * @return The table element that computed this value, or null if not found/set
     */
    public static Object getComputingTable(String name) {
        if (name == null || computedByTable == null) return null;
        return computedByTable.get(name);
    }
    
    /**
     * Get the master table element for a specific stock name
     * This is a convenience method that casts the result to TableElm
     * 
     * @param stockName The stock name to look up
     * @return The master TableElm for this stock, or null if not found
     */
    public static TableElm getMasterTable(String stockName) {
        Object table = getComputingTable(stockName);
        if (table instanceof TableElm) {
            return (TableElm) table;
        }
        return null;
    }
    
    /**
     * Check if a specific table element is the master computer for a given value name
     * 
     * @param name The name/key of the computed value
     * @param table The table element to check
     * @return true if this table is the master computer for this value
     */
    public static boolean isMasterTable(String name, Object table) {
        if (name == null || table == null) return false;
        Object masterTable = getComputingTable(name);
        return table.equals(masterTable);
    }
    
    /**
     * Clear all computed values (current, pending, and converged)
     * Called by CirSim when resetting the circuit state
     */
    public static void clearComputedValues() {
        if (computedValues != null) {
            computedValues.clear();
        }
        if (pendingValues != null) {
            pendingValues.clear();
        }
        if (convergedValues != null) {
            convergedValues.clear();
        }
        if (computedByTable != null) {
            computedByTable.clear();
        }
    }
    
    /**
     * Reset the "computed this step" tracking flags
     * Called by CirSim at the start of each simulation step
     */
    public static void resetComputedFlags() {
        ensureInitialized();
        computedThisStep.clear();
    }
    
    /**
     * Check if a value has been computed in the current simulation step
     * Used to avoid duplicate computations and circular dependencies
     * 
     * @param name The name/key to check
     * @return true if the value was computed this step, false otherwise
     */
    public static boolean isComputedThisStep(String name) {
        if (computedThisStep == null) return false;
        return computedThisStep.contains(name);
    }
    
    /**
     * Mark a value as having been computed in the current simulation step
     * Used by elements to track their computation to avoid cycles
     * 
     * @param name The name/key of the value that was computed
     */
    public static void markComputedThisStep(String name) {
        if (name == null) return;
        ensureInitialized();
        computedThisStep.add(name);
    }
    
    /**
     * Get all computed value names (for debugging/inspection)
     * 
     * @return Array of all computed value names, or empty array if none
     */
    public static String[] getComputedValueNames() {
        if (computedValues == null || computedValues.isEmpty()) {
            return new String[0];
        }
        Set<String> keySet = computedValues.keySet();
        return keySet.toArray(new String[keySet.size()]);
    }
    
    /**
     * Get all computed value names as a Set
     * 
     * @return Set of all computed value names, or null if none
     */
    public static Set<String> getAllNames() {
        if (computedValues == null || computedValues.isEmpty()) {
            return null;
        }
        return computedValues.keySet();
    }
    
    /**
     * Get the number of computed values currently stored
     * 
     * @return Number of computed values
     */
    public static int getComputedValueCount() {
        return (computedValues != null) ? computedValues.size() : 0;
    }
    
    /**
     * Register a table element as wanting to compute a specific value
     * This is used during circuit initialization to determine which table
     * should be the "master" computer for each output name when multiple
     * tables have the same output name.
     * 
     * The table with the highest priority becomes the master.
     * If priorities are equal, the first table to register becomes the master.
     * 
     * @param name The output name this table wants to compute
     * @param table The table element
     * @param priority The priority of this table (higher = higher priority)
     * @return true if this table became the master, false if another table is already master with higher/equal priority
     */
    public static boolean registerMasterTable(String name, Object table, int priority) {
        if (name == null || name.isEmpty() || table == null) return false;
        
        ensureInitialized();
        
        // Get table name for logging
        String tableName = "unknown";
        if (table instanceof TableElm) {
            tableName = ((TableElm)table).getTableTitle();
        }
        
        // If no table is registered for this name yet, this table becomes the master
        if (!computedByTable.containsKey(name)) {
            computedByTable.put(name, table);
            masterTablePriorities.put(name, priority);
            // CirSim.console("[PRIORITY] Stock '" + name + "': Table '" + tableName + "' is FIRST to register (priority=" + priority + ")");
            return true;
        }
        
        // Get current master info
        Object currentMaster = computedByTable.get(name);
        String currentMasterName = "unknown";
        if (currentMaster instanceof TableElm) {
            currentMasterName = ((TableElm)currentMaster).getTableTitle();
        }
        
        // Check if this table has higher priority than the current master
        Integer currentPriority = masterTablePriorities.get(name);
        if (currentPriority == null || priority > currentPriority) {
            // This table has higher priority - replace the current master
            // CirSim.console("[PRIORITY] Stock '" + name + "': Table '" + tableName + "' (priority=" + priority + ") REPLACES '" + currentMasterName + "' (priority=" + currentPriority + ")");
            computedByTable.put(name, table);
            masterTablePriorities.put(name, priority);
            return true;
        }
        
        // Another table is already the master with equal or higher priority
        // CirSim.console("[PRIORITY] Stock '" + name + "': Table '" + tableName + "' (priority=" + priority + ") loses to '" + currentMasterName + "' (priority=" + currentPriority + ")");
        return false;
    }
    
    /**
     * Register a table element as wanting to compute a specific value (backward compatibility)
     * Uses default priority of 5
     * 
     * @param name The output name this table wants to compute
     * @param table The table element
     * @return true if this table became the master, false if another table is already master
     */
    public static boolean registerMasterTable(String name, Object table) {
        return registerMasterTable(name, table, 5); // Default priority
    }
    
    /**
     * Clear the master table registrations
     * Called when the circuit is reset or rebuilt
     */
    public static void clearMasterTables() {
        // CirSim.console("[PRIORITY] clearMasterTables() called - all master registrations cleared");
        if (computedByTable != null) {
            computedByTable.clear();
        }
        if (masterTablePriorities != null) {
            masterTablePriorities.clear();
        }
    }
    
    /**
     * Debug method to dump complete state of master tables and priorities
     */
    public static void debugDumpMasterTables() {
        CirSim.console("=== Master Table Debug Dump ===");
        if (computedByTable == null || computedByTable.isEmpty()) {
            CirSim.console("No master tables registered");
            return;
        }
        
        CirSim.console("Total stocks: " + computedByTable.size());
        for (String stockName : computedByTable.keySet()) {
            Object table = computedByTable.get(stockName);
            Integer priority = masterTablePriorities.get(stockName);
            
            String tableName = "unknown";
            if (table instanceof TableElm) {
                tableName = ((TableElm)table).getTableTitle();
            }
            
            CirSim.console("  Stock '" + stockName + "': Table '" + tableName + "' (priority=" + priority + ")");
        }
        CirSim.console("=== End Master Table Dump ===");
    }
    
    /**
     * Debug method to get information about master table assignments
     * 
     * @return Array of strings describing master table assignments
     */
    public static String[] getMasterTableInfo() {
        if (computedByTable == null || computedByTable.isEmpty()) {
            return new String[] { "No master tables registered" };
        }
        
        String[] info = new String[computedByTable.size()];
        int i = 0;
        for (String name : computedByTable.keySet()) {
            Object table = computedByTable.get(name);
            String tableInfo = (table != null) ? table.getClass().getSimpleName() + "@" + table.hashCode() : "null";
            info[i++] = name + " -> " + tableInfo;
        }
        return info;
    }
    
    /**
     * Get all master stock names (all keys in computedByTable)
     * Used by CurrentTransactionsMatrixElm to auto-populate columns
     * 
     * @return Array of master stock names, or empty array if none
     */
    public static String[] getAllMasterStockNames() {
        if (computedByTable == null || computedByTable.isEmpty()) {
            return new String[0];
        }
        Set<String> keySet = computedByTable.keySet();
        return keySet.toArray(new String[keySet.size()]);
    }
    
    /**
     * Get all master stock names excluding tables with specified title
     * Used by CurrentTransactionsMatrixElm to exclude itself from the list
     * 
     * @param excludeTitle Title of tables to exclude (e.g., "Current Transactions Matrix")
     * @return Array of master stock names from non-excluded tables
     */
    public static String[] getMasterStockNamesExcluding(String excludeTitle) {
        if (computedByTable == null || computedByTable.isEmpty()) {
            return new String[0];
        }
        
        // Filter out stocks from tables with the excluded title
        java.util.ArrayList<String> filtered = new java.util.ArrayList<String>();
        for (String name : computedByTable.keySet()) {
            Object table = computedByTable.get(name);
            if (table instanceof TableElm) {
                TableElm tableElm = (TableElm) table;
                if (excludeTitle == null || !excludeTitle.equals(tableElm.tableTitle)) {
                    filtered.add(name);
                }
            } else {
                // Not a TableElm, include it
                filtered.add(name);
            }
        }
        
        return filtered.toArray(new String[filtered.size()]);
    }
}