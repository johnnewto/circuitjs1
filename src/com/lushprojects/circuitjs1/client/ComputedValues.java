/*    
    Copyright (C) Paul Falstad and Iain Sharp

    This file is part of CircuitJS1.

    CircuitJS1 is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    CircuitJS1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with CircuitJS1.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.lushprojects.circuitjs1.client;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

/**
 * ComputedValues - Manages computed values storage and tracking for circuit elements
 * 
 * This class provides a centralized way to store and retrieve computed values that
 * are generated by elements like TableElm and consumed by elements like TableVoltageElm.
 * It replaces the computed values functionality that was previously embedded in LabeledNodeElm.
 * 
 * Key features:
 * - Store computed values by name (String key -> Double value)
 * - Track which values have been computed in the current simulation step
 * - Clear all values or reset tracking flags as needed
 * - Thread-safe access to computed values
 */
public class ComputedValues {
    
    // Storage for computed values: name -> value
    private static HashMap<String, Double> computedValues;
    
    // Track which values have been computed this simulation step
    private static Set<String> computedThisStep;
    
    // Initialize storage if needed
    private static void ensureInitialized() {
        if (computedValues == null) {
            computedValues = new HashMap<String, Double>();
        }
        if (computedThisStep == null) {
            computedThisStep = new HashSet<String>();
        }
    }
    
    /**
     * Set a computed value for a given name
     * Used by elements like TableElm to store calculated values
     * 
     * @param name The name/key for the computed value
     * @param value The computed value to store
     */
    public static void setComputedValue(String name, double value) {
        if (name == null || name.isEmpty()) return;
        
        ensureInitialized();
        computedValues.put(name, value);
    }
    
    /**
     * Get a computed value by name
     * Used by elements like TableVoltageElm and Expr to retrieve values
     * 
     * @param name The name/key of the computed value
     * @return The computed value, or null if not found
     */
    public static Double getComputedValue(String name) {
        if (name == null || computedValues == null) return null;
        return computedValues.get(name);
    }
    
    /**
     * Check if a computed value exists for the given name
     * 
     * @param name The name/key to check
     * @return true if a computed value exists, false otherwise
     */
    public static boolean hasComputedValue(String name) {
        if (name == null || computedValues == null) return false;
        return computedValues.containsKey(name) && computedValues.get(name) != null;
    }
    
    /**
     * Clear all computed values
     * Called by CirSim when resetting the circuit state
     */
    public static void clearComputedValues() {
        if (computedValues != null) {
            computedValues.clear();
        }
    }
    
    /**
     * Reset the "computed this step" tracking flags
     * Called by CirSim at the start of each simulation step
     */
    public static void resetComputedFlags() {
        ensureInitialized();
        computedThisStep.clear();
    }
    
    /**
     * Check if a value has been computed in the current simulation step
     * Used to avoid duplicate computations and circular dependencies
     * 
     * @param name The name/key to check
     * @return true if the value was computed this step, false otherwise
     */
    public static boolean isComputedThisStep(String name) {
        if (computedThisStep == null) return false;
        return computedThisStep.contains(name);
    }
    
    /**
     * Mark a value as having been computed in the current simulation step
     * Used by elements to track their computation to avoid cycles
     * 
     * @param name The name/key of the value that was computed
     */
    public static void markComputedThisStep(String name) {
        if (name == null) return;
        ensureInitialized();
        computedThisStep.add(name);
    }
    
    /**
     * Get all computed value names (for debugging/inspection)
     * 
     * @return Array of all computed value names, or empty array if none
     */
    public static String[] getComputedValueNames() {
        if (computedValues == null || computedValues.isEmpty()) {
            return new String[0];
        }
        Set<String> keySet = computedValues.keySet();
        return keySet.toArray(new String[keySet.size()]);
    }
    
    /**
     * Get the number of computed values currently stored
     * 
     * @return Number of computed values
     */
    public static int getComputedValueCount() {
        return (computedValues != null) ? computedValues.size() : 0;
    }
}